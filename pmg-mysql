#!/bin/bash
# PMG - PNETLab Manager with MySQL Integration
# Version: 3.2-mysql
# Based on ishare2-cli
# Modified to use correct LabHub API endpoints and MySQL logging

# Default configuration
USE_ARIA2C=false
SSL_CHECK="true"
CHANNEL="main"
VERSION="3.2-mysql"

# Initialize variables
PMG_DIR="/opt/pmg"
LOG_FILE="$PMG_DIR/pmg.log"
TEMP_JSON="$PMG_DIR/labhub.json"

# MySQL Configuration
MYSQL_SOCKET="/media/2d05/revoltado/private/mysql/socket"
MYSQL_USER="root"
MYSQL_PASS="2n2Qkc7TtzLgOVxY"
MYSQL_DB="pmg_stats"

# Colors
RED='\033[31m'
YELLOW='\033[1;33m'
GREEN='\033[32m'
BLUE='\033[34m'
NO_COLOR='\033[0m'

# Script name
SCR_NAME_EXEC=$0
SCR_NAME_EXEC_FP=$(realpath "$0")
SCR_NAME=$(basename "$SCR_NAME_EXEC")
SCR_NAME=${SCR_NAME%.*}

# Configuration file
PMG_CONF_FILE=$PMG_DIR/pmg.conf

logger() {
    local log_level=${1^^}
    shift

    if [[ ! -f "$LOG_FILE" ]]; then
        mkdir -p "$PMG_DIR" 2>/dev/null
        touch "$LOG_FILE" 2>/dev/null
    fi

    if [[ -z "$LOG_FILE" ]]; then
        return 1
    fi

    if [[ -z "$SCR_NAME" ]]; then
        SCR_NAME="PMG"
    fi

    echo -e "[$log_level][$SCR_NAME] $(date '+%Y-%m-%d %H:%M:%S'): $*" >>"$LOG_FILE" 2>/dev/null
}

# MySQL Functions
mysql_exec() {
    local query="$1"
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -D"$MYSQL_DB" -e "$query" 2>/dev/null
}

mysql_check_connection() {
    if mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -e "SELECT 1;" &>/dev/null; then
        return 0
    else
        return 1
    fi
}

mysql_init_database() {
    echo -e "${YELLOW}[+] Initializing MySQL database...${NO_COLOR}"
    
    # Check connection
    if ! mysql_check_connection; then
        echo -e "${RED}[-] Failed to connect to MySQL server${NO_COLOR}"
        echo -e "${YELLOW}[!] MySQL features will be disabled${NO_COLOR}"
        return 1
    fi
    
    # Create database if not exists
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -e "CREATE DATABASE IF NOT EXISTS $MYSQL_DB;" 2>/dev/null
    
    # Create tables
    mysql_exec "
    CREATE TABLE IF NOT EXISTS downloads (
        id INT AUTO_INCREMENT PRIMARY KEY,
        image_type VARCHAR(50) NOT NULL,
        image_id INT NOT NULL,
        image_name VARCHAR(255) NOT NULL,
        image_size VARCHAR(50),
        download_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        download_status ENUM('success', 'failed', 'in_progress') DEFAULT 'in_progress',
        download_time_seconds INT,
        error_message TEXT,
        INDEX idx_type (image_type),
        INDEX idx_date (download_date),
        INDEX idx_status (download_status)
    );
    "
    
    mysql_exec "
    CREATE TABLE IF NOT EXISTS searches (
        id INT AUTO_INCREMENT PRIMARY KEY,
        search_type VARCHAR(50),
        search_filter VARCHAR(255),
        results_count INT,
        search_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        INDEX idx_date (search_date)
    );
    "
    
    mysql_exec "
    CREATE TABLE IF NOT EXISTS usage_stats (
        id INT AUTO_INCREMENT PRIMARY KEY,
        action VARCHAR(100) NOT NULL,
        details TEXT,
        execution_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        INDEX idx_action (action),
        INDEX idx_date (execution_date)
    );
    "
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}[‚úì] MySQL database initialized successfully${NO_COLOR}"
        logger info "MySQL database initialized"
        return 0
    else
        echo -e "${RED}[-] Failed to initialize MySQL database${NO_COLOR}"
        return 1
    fi
}

mysql_log_download() {
    local image_type="$1"
    local image_id="$2"
    local image_name="$3"
    local image_size="$4"
    local status="$5"
    local download_time="$6"
    local error_msg="$7"
    
    if ! mysql_check_connection; then
        return 1
    fi
    
    # Escape single quotes in variables
    image_name="${image_name//\'/\\\'}"
    error_msg="${error_msg//\'/\\\'}"
    
    mysql_exec "
    INSERT INTO downloads (image_type, image_id, image_name, image_size, download_status, download_time_seconds, error_message)
    VALUES ('$image_type', $image_id, '$image_name', '$image_size', '$status', $download_time, '$error_msg');
    "
    
    logger info "Download logged to MySQL: $image_type/$image_name - $status"
}

mysql_log_search() {
    local search_type="$1"
    local search_filter="$2"
    local results_count="$3"
    
    if ! mysql_check_connection; then
        return 1
    fi
    
    search_filter="${search_filter//\'/\\\'}"
    
    mysql_exec "
    INSERT INTO searches (search_type, search_filter, results_count)
    VALUES ('$search_type', '$search_filter', $results_count);
    "
}

mysql_log_action() {
    local action="$1"
    local details="$2"
    
    if ! mysql_check_connection; then
        return 1
    fi
    
    details="${details//\'/\\\'}"
    
    mysql_exec "
    INSERT INTO usage_stats (action, details)
    VALUES ('$action', '$details');
    "
}

mysql_show_stats() {
    if ! mysql_check_connection; then
        echo -e "${RED}[-] MySQL connection not available${NO_COLOR}"
        return 1
    fi
    
    echo -e "${BLUE}=== PMG Statistics ===${NO_COLOR}\n"
    
    # Total downloads
    echo -e "${YELLOW}üìä Download Statistics:${NO_COLOR}"
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -D"$MYSQL_DB" -t -e "
    SELECT 
        download_status as 'Status',
        COUNT(*) as 'Count',
        ROUND(AVG(download_time_seconds), 2) as 'Avg Time (s)'
    FROM downloads 
    GROUP BY download_status;
    " 2>/dev/null
    
    echo ""
    
    # Downloads by type
    echo -e "${YELLOW}üì¶ Downloads by Type:${NO_COLOR}"
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -D"$MYSQL_DB" -t -e "
    SELECT 
        image_type as 'Type',
        COUNT(*) as 'Downloads',
        SUM(CASE WHEN download_status = 'success' THEN 1 ELSE 0 END) as 'Successful'
    FROM downloads 
    GROUP BY image_type;
    " 2>/dev/null
    
    echo ""
    
    # Recent downloads
    echo -e "${YELLOW}üì• Recent Downloads (Last 10):${NO_COLOR}"
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -D"$MYSQL_DB" -t -e "
    SELECT 
        DATE_FORMAT(download_date, '%Y-%m-%d %H:%i') as 'Date',
        image_type as 'Type',
        image_name as 'Image',
        download_status as 'Status'
    FROM downloads 
    ORDER BY download_date DESC 
    LIMIT 10;
    " 2>/dev/null
    
    echo ""
    
    # Search statistics
    echo -e "${YELLOW}üîç Search Statistics:${NO_COLOR}"
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -D"$MYSQL_DB" -t -e "
    SELECT 
        search_type as 'Type',
        COUNT(*) as 'Searches',
        ROUND(AVG(results_count), 0) as 'Avg Results'
    FROM searches 
    GROUP BY search_type;
    " 2>/dev/null
}

mysql_export_stats() {
    local output_file="${1:-/tmp/pmg_stats_$(date +%Y%m%d_%H%M%S).csv}"
    
    if ! mysql_check_connection; then
        echo -e "${RED}[-] MySQL connection not available${NO_COLOR}"
        return 1
    fi
    
    echo -e "${YELLOW}[+] Exporting statistics to: $output_file${NO_COLOR}"
    
    mysql --socket="$MYSQL_SOCKET" -u"$MYSQL_USER" -p"$MYSQL_PASS" -D"$MYSQL_DB" -e "
    SELECT 
        d.download_date,
        d.image_type,
        d.image_name,
        d.image_size,
        d.download_status,
        d.download_time_seconds,
        d.error_message
    FROM downloads d
    ORDER BY d.download_date DESC;
    " 2>/dev/null | sed 's/\t/,/g' > "$output_file"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}[‚úì] Statistics exported to: $output_file${NO_COLOR}"
    else
        echo -e "${RED}[-] Failed to export statistics${NO_COLOR}"
    fi
}

print_box() {
    messages=("$@")
    max_length=0
    IFS=$'\n'
    all_lines=()
    for message in "${messages[@]}"; do
        readarray -t lines <<<"$message"
        for line in "${lines[@]}"; do
            all_lines+=("$line")
            length=${#line}
            if ((length > max_length)); then
                max_length=$length
            fi
        done
    done
    IFS=$' \t\n'

    echo -e "${YELLOW}‚îå$(printf '‚îÄ%.0s' $(seq 1 $((max_length + 4))))‚îê${NO_COLOR}"
    for line in "${all_lines[@]}"; do
        printf "${YELLOW}‚îÇ${NO_COLOR} %-$(($max_length + 2))s ${YELLOW}‚îÇ${NO_COLOR}\n" "$line"
    done
    echo -e "${YELLOW}‚îî$(printf '‚îÄ%.0s' $(seq 1 $((max_length + 4))))‚îò${NO_COLOR}"
}

print_separator() {
    local TITLE=$1
    local WIDTH=${#TITLE}
    local SEPARATOR=""

    for ((i = 0; i < WIDTH + 8; i++)); do
        SEPARATOR+="="
    done

    echo -e "${BLUE}$SEPARATOR${NO_COLOR}"
    echo -e "\033[1;33m    ${TITLE}    \033[0m"
    echo -e "${BLUE}$SEPARATOR${NO_COLOR}"
}

check_user_is_root() {
    if ! [[ "$(id -u)" == 0 ]]; then
        user=$(whoami)
        echo -e "${RED}[!] This script requires root privileges. Current user \"$user\" does not have enough permissions.${NO_COLOR}"
        exit 1
    fi
}

check_pmg_dir() {
    if [[ ! -d $PMG_DIR ]]; then
        create_pmg_dir
    fi
}

create_pmg_dir() {
    echo -e "${YELLOW}[!] Creating PMG directory...${NO_COLOR}"
    if ! mkdir -p $PMG_DIR 2>/dev/null; then
        error_message=$(mkdir -p $PMG_DIR 2>&1 >/dev/null)
        echo -e "${RED}[-] Failed to create PMG directory. Error: $error_message${NO_COLOR}"
        exit 1
    fi
    logger info "PMG directory created successfully."
}

install_dependencies() {
    echo -e "${YELLOW}[+] PMG needs to install some dependencies to work properly.${NO_COLOR}"
    local packages=("curl" "wget" "jq" "unzip" "mysql-client")
    echo -e "${YELLOW}[+] List of packages to be installed: ${NO_COLOR}"
    for package in "${packages[@]}"; do
        echo -e "${YELLOW} -${NO_COLOR} $package"
    done
    echo -e "${YELLOW}[+] Installing dependencies...${NO_COLOR}"

    for package in "${packages[@]}"; do
        install_package "$package"
    done
}

install_package() {
    local package_name=$1
    if ! command -v "$package_name" &>/dev/null && ! dpkg -l | grep -q "^ii.*$package_name"; then
        echo -e "${YELLOW}[+] Installing $package_name...${NO_COLOR}"
        apt-get update -qq >/dev/null 2>&1
        if ! apt-get install -qq -y "$package_name" >/dev/null 2>&1; then
            echo -e "${RED}[-] Failed to install $package_name.${NO_COLOR}"
            logger error "Failed to install $package_name."
            return 1
        fi
        echo -e "${GREEN}[+] $package_name installed successfully.${NO_COLOR}"
    fi
}

check_installed() {
    PACKAGE=$1
    if ! command -v "$PACKAGE" &>/dev/null; then
        echo -e "${YELLOW}[!] $PACKAGE is not installed. Installing...${NO_COLOR}"
        install_package "$PACKAGE"
        if ! command -v "$PACKAGE" &>/dev/null; then
            echo -e "${RED}[-] Error: Failed to install $PACKAGE.${NO_COLOR}"
            logger error "Failed to install $PACKAGE."
            exit 1
        fi
    fi
}

fetch_json() {
    check_installed "jq"
    
    REPO_URL="https://api.github.com/repos/ishare2-org/mirrors/releases/latest"

    logger info "Fetching the latest release information from: $REPO_URL"

    response=$(curl -sL "$REPO_URL" 2>/dev/null) || {
        logger error "Failed to fetch release metadata from: $REPO_URL"
        echo -e "${RED}[-] Failed to connect to GitHub API. Check your internet connection.${NO_COLOR}"
        echo -e "${YELLOW}[!] Running connection test...${NO_COLOR}"
        connection_tests
        exit 1
    }

    labhub_url=$(echo "$response" | jq -r '.assets[] | select(.name == "labhub.json") | .browser_download_url' 2>/dev/null)

    if [[ -z "$labhub_url" || "$labhub_url" == "null" ]]; then
        logger error "labhub.json not found in release metadata"
        echo -e "${RED}[-] Error: Failed to get image index URL from the repository.${NO_COLOR}"
        exit 1
    fi

    logger info "Downloading labhub.json from: $labhub_url"
    echo -e "${YELLOW}[+] Downloading image index...${NO_COLOR}"
    
    if curl -sSL -o "$TEMP_JSON" "$labhub_url" 2>/dev/null; then
        logger info "labhub.json downloaded successfully."
        echo -e "${GREEN}[+] Image index downloaded successfully.${NO_COLOR}"
    else
        logger error "Failed to download labhub.json from: $labhub_url"
        echo -e "${RED}[-] Failed to download the JSON index file.${NO_COLOR}"
        connection_tests
        exit 1
    fi

    if ! jq -e . <"$TEMP_JSON" >/dev/null 2>&1; then
        logger error "Invalid JSON structure in: $TEMP_JSON"
        echo -e "${RED}[-] Error: Invalid JSON index file.${NO_COLOR}"
        exit 1
    else
        logger info "Valid JSON file confirmed: $TEMP_JSON"
    fi
}

download_file_wget() {
    mkdir -p $PMG_DIR/tmp 2>/dev/null
    local url="$1"
    local output_dir="$2"
    local output_name="$3"
    
    if [[ -z "$output_name" ]]; then
        output_name=$(basename "$url")
    fi
    
    local output="$output_dir/$output_name"
    logger info "Downloading file from $url..."

    if [ "$SSL_CHECK" = "true" ]; then
        wget -O "$output" "$url" -q --show-progress --content-disposition -T 300 2>&1
    else
        wget -O "$output" "$url" -q --show-progress --content-disposition --no-check-certificate -T 300 2>&1
    fi

    if [ $? -eq 0 ]; then
        logger info "File downloaded successfully to $output."
        return 0
    else
        echo -e "${RED}[-] Error: Unable to download the file.${NO_COLOR}"
        logger error "Failed to download the file."
        return 1
    fi
}

download_file() {
    local url="$1"
    local output_dir="$2"
    local output_name="$3"
    
    USE_ARIA2C=$(grep "USE_ARIA2C" $PMG_CONF_FILE 2>/dev/null | cut -d "=" -f2)
    
    logger info "Downloading file from $url to $output_dir/$output_name"

    if [[ $USE_ARIA2C == "true" ]] && command -v aria2c &>/dev/null; then
        download_file_aria2 "$url" "$output_dir" "$output_name"
    else
        download_file_wget "$url" "$output_dir" "$output_name"
    fi
}

download_file_aria2() {
    local url="$1"
    local output_dir="$2"
    local output_name="$3"

    logger info "Downloading with aria2c: $url"
    
    if [ "$SSL_CHECK" = "true" ]; then
        aria2c --console-log-level=warn -j 2 -c --split=4 --min-split-size=20M --max-connection-per-server=4 --download-result=hide --allow-overwrite=true --dir="$output_dir" --out="$output_name" "$url" 2>&1
    else
        aria2c --console-log-level=warn -j 2 -c --split=4 --min-split-size=20M --max-connection-per-server=4 --download-result=hide --check-certificate=false --allow-overwrite=true --dir="$output_dir" --out="$output_name" "$url" 2>&1
    fi

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}[+] File downloaded successfully to $output_dir/$output_name${NO_COLOR}"
        return 0
    else
        echo -e "${RED}[-] Error: Unable to download the file with aria2c.${NO_COLOR}"
        return 1
    fi
}

search_images() {
    TYPE_INPUT="${1,,}"
    FILTER="${2:-}"
    
    fetch_json

    TYPE=${TYPE_INPUT^^}
    [[ "$TYPE" == "BIN" ]] && TYPE="IOL"

    VALID_TYPES=("IOL" "QEMU" "DYNAMIPS")
    SEARCH_ACROSS=false
    
    if [[ "$TYPE" == "ALL" || ! " ${VALID_TYPES[*]} " =~ " ${TYPE} " ]]; then
        SEARCH_ACROSS=true
        [[ ! "$TYPE" == "ALL" ]] && FILTER="$TYPE_INPUT"
    fi

    if [[ "$SEARCH_ACROSS" == true ]]; then
        print_separator "Searching across all types for \"$FILTER\""

        data=$(jq -r --arg filter "$FILTER" '
          . as $root
          | ["IOL", "QEMU", "DYNAMIPS"] 
          | map($root[.][]? 
            | select(($filter | length == 0) or (.name | test($filter; "i")))
            | [.id, .name, .type, .metadata.total_human_size] 
            | @tsv) 
          | .[] 
        ' "$TEMP_JSON" 2>/dev/null)

        if [[ -z "$data" ]]; then
            echo -e "\n${RED}No matching images found for \"$FILTER\"${NO_COLOR}"
            results_count=0
        else
            {
                echo -e "ID\tNAME\tTYPE\tSIZE"
                echo -e "--\t----\t----\t----"
                echo "$data"
            } | column -t -s $'\t'

            results_count=$(echo "$data" | wc -l)
            echo -e "\n${GREEN}$results_count image(s) found${NO_COLOR}"
        fi
    else
        print_separator "Available $TYPE images"

        data=$(jq -r --arg type "$TYPE" --arg filter "$FILTER" '
          .[$type][]? 
          | select(($filter | length == 0) or (.name | test($filter; "i"))) 
          | [.id, .name, .metadata.total_human_size] 
          | @tsv
        ' "$TEMP_JSON" 2>/dev/null)

        if [[ -z "$data" ]]; then
            echo -e "\n${RED}No $TYPE images found${NO_COLOR}"
            if [[ -n "$FILTER" ]]; then
                echo -e "${YELLOW}[!] Try searching without filter: pmg search ${TYPE_INPUT}${NO_COLOR}"
            fi
            results_count=0
        else
            {
                echo -e "ID\tNAME\tSIZE"
                echo -e "--\t----\t----"
                echo "$data"
            } | column -t -s $'\t'

            results_count=$(echo "$data" | wc -l)
            echo -e "\n${GREEN}$results_count $TYPE image(s) found${NO_COLOR}"
        fi
    fi
    
    # Log search to MySQL
    mysql_log_search "$TYPE" "$FILTER" "$results_count"
    
    echo -e "${YELLOW}[!]${NO_COLOR} Use: ${GREEN}pmg pull <type> <id>${NO_COLOR} to download an image"
}

pull_images() {
    local IMAGE_TYPE=$1
    local IMAGE_ID=$2
    local OVERWRITE=$3
    
    local start_time=$(date +%s)

    [[ -z "$IMAGE_TYPE" ]] && {
        echo "Usage: pmg pull <type> <id> [--overwrite]"
        exit 1
    }
    [[ -z "$IMAGE_ID" || ! "$IMAGE_ID" =~ ^[0-9]+$ ]] && {
        echo -e "${RED}Invalid ID: Must be a number${NO_COLOR}"
        exit 1
    }

    IMAGE_TYPE=${IMAGE_TYPE^^}
    [[ "$IMAGE_TYPE" == "BIN" ]] && IMAGE_TYPE="IOL"
    [[ ! "$IMAGE_TYPE" =~ ^(QEMU|IOL|DYNAMIPS)$ ]] && {
        echo -e "${RED}Invalid type. Use: qemu, iol, or dynamips${NO_COLOR}"
        exit 1
    }

    fetch_json

    local image_data image_name install_path protocol hostname prefix download_urls image_size
    
    image_data=$(jq -r --arg type "$IMAGE_TYPE" --argjson id "$IMAGE_ID" \
        '.[$type][] | select(.id == $id)' "$TEMP_JSON" 2>/dev/null)
    
    [[ -z "$image_data" ]] && {
        echo -e "${RED}Image with ID $IMAGE_ID not found in $IMAGE_TYPE${NO_COLOR}"
        echo -e "${YELLOW}Use 'pmg search ${IMAGE_TYPE,,}' to see available images${NO_COLOR}"
        mysql_log_download "$IMAGE_TYPE" "$IMAGE_ID" "unknown" "0" "failed" "0" "Image not found"
        exit 1
    }

    image_name=$(jq -r '.name' <<<"$image_data")
    image_size=$(jq -r '.metadata.total_human_size' <<<"$image_data")
    install_path=$(jq -r '.metadata.install_path' <<<"$image_data")
    protocol=$(jq -r '.url_properties.protocol' "$TEMP_JSON")
    
    hostname=$(jq -r '.url_properties.hostnames.drive // .url_properties.hostnames.main' "$TEMP_JSON")
    prefix=$(jq -r '.url_properties.prefixes.drive // .url_properties.prefixes.main' "$TEMP_JSON")

    echo -e "${YELLOW}[!] IMAGE INFO${NO_COLOR}"
    printf "%-20s: %s\n" "Name" "$image_name"
    printf "%-20s: %s\n" "Size" "$image_size"
    printf "%-20s: %s\n" "Type" "$IMAGE_TYPE"
    printf "%-20s: %s\n" "Path" "$install_path"
    printf "%-20s: %s\n" "Host" "$hostname"
    echo ""

    if [ -e "$install_path/$image_name" ] && [ "$OVERWRITE" != "--overwrite" ]; then
        echo -e "${YELLOW}File already exists. Use --overwrite to replace it${NO_COLOR}"
        mysql_log_download "$IMAGE_TYPE" "$IMAGE_ID" "$image_name" "$image_size" "failed" "0" "File already exists"
        exit 0
    fi

    mkdir -p "$install_path" 2>/dev/null

    download_urls=()
    while IFS= read -r url; do
        full_url="$protocol://$hostname$prefix$url"
        download_urls+=("$full_url")
    done < <(jq -r '.files[].path' <<<"$image_data")

    local download_success=true
    local error_message=""
    
    for url in "${download_urls[@]}"; do
        filename=$(basename "$url")
        
        echo -e "${YELLOW}[+] Downloading: $filename${NO_COLOR}"
        download_file "$url" "$install_path" "$filename"
        
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}[‚úì] Downloaded: $filename${NO_COLOR}"
        else
            echo -e "${RED}[‚úó] Failed to download: $filename${NO_COLOR}"
            download_success=false
            error_message="Failed to download $filename"
            break
        fi
    done

    if [ "$IMAGE_TYPE" = "QEMU" ] && [ "$download_success" = true ]; then
        handle_compressed_files "$image_name" "$install_path"
    fi

    if [ "$download_success" = true ]; then
        fix_permissions "$install_path"
        echo -e "${GREEN}[‚úì] Installation completed successfully!${NO_COLOR}"
        
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        
        mysql_log_download "$IMAGE_TYPE" "$IMAGE_ID" "$image_name" "$image_size" "success" "$duration" ""
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        
        mysql_log_download "$IMAGE_TYPE" "$IMAGE_ID" "$image_name" "$image_size" "failed" "$duration" "$error_message"
        exit 1
    fi
}

handle_compressed_files() {
    local foldername=$1
    local dir=$2
    
    if ls "${dir}"/*.tgz &>/dev/null 2>&1; then
        file=$(ls "${dir}"/*.tgz)
        echo -e "${YELLOW}[+] Extracting .tgz file...${NO_COLOR}"
        tar -xzf "$file" -C "$dir" 2>/dev/null && rm "$file"
    fi
    
    if ls "${dir}"/*.zip &>/dev/null 2>&1; then
        file=$(ls "${dir}"/*.zip)
        echo -e "${YELLOW}[+] Extracting .zip file...${NO_COLOR}"
        unzip -q -o "$file" -d "$dir" 2>/dev/null && rm "$file"
    fi
}

fix_permissions() {
    local path=$1
    echo -e "${YELLOW}[+] Fixing permissions...${NO_COLOR}"
    /opt/unetlab/wrappers/unl_wrapper -a fixpermissions 2>/dev/null || chmod -R 755 "$path" 2>/dev/null
    echo -e "${GREEN}[‚úì] Permissions fixed${NO_COLOR}"
}

connection_tests() {
    declare -A SERVICES=(
        ["GitHub API"]="api.github.com"
        ["GitHub Raw"]="raw.githubusercontent.com"
        ["Google DNS"]="8.8.8.8"
    )

    local all_services_reachable=true
    echo -e "${YELLOW}[-] Running connection tests...${NO_COLOR}"

    for service in "${!SERVICES[@]}"; do
        echo -e "${YELLOW}[-] Checking $service...${NO_COLOR}"
        if ping -q -c 3 -W 3 "${SERVICES[$service]}" >/dev/null 2>&1; then
            echo -e "${GREEN}[+] $service is reachable${NO_COLOR}"
        else
            echo -e "${RED}[-] $service is NOT reachable${NO_COLOR}"
            all_services_reachable=false
        fi
    done

    if [ "$all_services_reachable" = true ]; then
        echo -e "${GREEN}[+] All services are reachable${NO_COLOR}"
        mysql_log_action "connectivity_test" "All services reachable"
        return 0
    else
        echo -e "${RED}[-] Some services are not reachable${NO_COLOR}"
        echo -e "${YELLOW}[!] Check your internet connection${NO_COLOR}"
        mysql_log_action "connectivity_test" "Some services unreachable"
        return 1
    fi
}

show_help() {
    cat <<EOF
${GREEN}PMG - PNETLab Manager v$VERSION${NO_COLOR}

${YELLOW}Syntax:${NO_COLOR}
  pmg [action] [param1] [param2] [--overwrite]

${YELLOW}Actions:${NO_COLOR}
  search      Search for images by type
  pull        Download an image by type and id
  stats       Show download and usage statistics (MySQL)
  export      Export statistics to CSV file
  initdb      Initialize MySQL database for statistics
  test        Test internet connectivity
  help        Show this help message
  version     Show PMG version

${YELLOW}Examples:${NO_COLOR}
  pmg search qemu              # Search all QEMU images
  pmg search qemu win          # Search QEMU images with 'win' in name
  pmg pull qemu 1              # Download QEMU image with ID 1
  pmg stats                    # Show statistics
  pmg export /tmp/stats.csv    # Export stats to CSV
  pmg initdb                   # Initialize MySQL database
  pmg test                     # Test connectivity

${YELLOW}MySQL Features:${NO_COLOR}
  - Download history tracking
  - Search statistics
  - Usage analytics
  - Export to CSV

${YELLOW}For more information:${NO_COLOR}
  github.com/Revoltado-RvT/PMG_V2
EOF
}

show_version() {
    echo -e "${GREEN}PMG v$VERSION${NO_COLOR}"
    echo "Based on ishare2-cli with MySQL integration"
    echo "github.com/Revoltado-RvT/PMG_V2"
}

create_config() {
    mkdir -p "$PMG_DIR" 2>/dev/null
    echo "USE_ARIA2C=false" >"$PMG_CONF_FILE"
    echo "SSL_CHECK=true" >>"$PMG_CONF_FILE"
    echo "CHANNEL=main" >>"$PMG_CONF_FILE"
    echo "MYSQL_ENABLED=true" >>"$PMG_CONF_FILE"
}

check_config() {
    if [[ ! -f $PMG_CONF_FILE ]]; then
        create_config
    fi
    source "$PMG_CONF_FILE" 2>/dev/null
}

selector() {
    case "$1" in
    "search")
        if [[ -z "$2" ]]; then
            echo -e "${RED}Usage: pmg search <type> [filter]${NO_COLOR}"
            echo -e "${YELLOW}Example: pmg search qemu win${NO_COLOR}"
            exit 1
        fi
        search_images "$2" "$3"
        ;;
    "pull")
        if [[ -z "$2" || -z "$3" ]]; then
            echo -e "${RED}Usage: pmg pull <type> <id> [--overwrite]${NO_COLOR}"
            echo -e "${YELLOW}Example: pmg pull qemu 1${NO_COLOR}"
            exit 1
        fi
        pull_images "$2" "$3" "$4"
        ;;
    "stats")
        mysql_show_stats
        ;;
    "export")
        mysql_export_stats "$2"
        ;;
    "initdb")
        mysql_init_database
        ;;
    "test")
        connection_tests
        ;;
    "help" | "--help" | "-h")
        show_help
        ;;
    "version" | "--version" | "-v")
        show_version
        ;;
    *)
        echo -e "${RED}Invalid command: $1${NO_COLOR}"
        echo -e "${YELLOW}Use 'pmg help' for usage information${NO_COLOR}"
        exit 1
        ;;
    esac
}

# Main execution
check_user_is_root
check_pmg_dir
check_config

# Try to initialize MySQL on first run
if [[ ! -f "$PMG_DIR/.mysql_initialized" ]]; then
    if mysql_init_database; then
        touch "$PMG_DIR/.mysql_initialized"
    fi
fi

if [ $# -eq 0 ]; then
    show_help
else
    selector "$@"
fi
